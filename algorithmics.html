<HEAD>
<TITLE>Algorithmics</TITLE>
</HEAD>
<BODY>
<P>
<H2>Algorithmics,<BR>the Mathematics of Program Construction</H2>
(<em>Translated from a description by Lambert Meertens.</em>)
<P>
How are computer programs constructed?
The usual way is that programmers get a (usually too vague) description of what is wanted, and then just start programming.
Everybody will agree that this is not the right method:
too often it goes wrong, and the production of software is too expensive.
But then, what is the good way?
<P>
In <em>algorithmics</em>, also known as <em>the mathematics of program construction</em>, one looks at <em>formal methods</em> to construct programs.
The most important question is not so much how a program can be derived from a specification, but rather how that can be done <em>effectively</em> and <em>efficiently</em> (and <em>elegantly</em>).
<P>
Looking at international research on this subject, there appears to be much attention for  the method of <em>program transformation</em>:
derive a program in a  step-by-step way through a series of &quot;transformations&quot; that preserve the meaning and hence the correctness.
A significant practical problem is that very many steps seem needed: the individual steps are too small.
In algorithmics a solution to this problem is searched for:
formalisms and theories are developed with which a whole series of little steps can be combined into one single step at a higher level.
Compare this with the development of higher programming languages: these make it possible to express compactly what needs many instructions in an assembler language.
It also resembles the way mathematics is built up with concepts, notations, and theorems that are used in later proofs.
<P>
An important source of inspiration for the research are concrete algorithms, or rather <em>classes</em> of algorithms.
For instance, what is the essence of parsing methods, or of shortest path methods?
How can we express the derivation of these algorithms in a clear and succinct way?
What systematic theory can be set up?
In this research quite fundamental questions pop up, that can be well studied with tools like <em>category theory</em> and <em>type theory</em>.
And besides theory formation, there is also an important more practical aspect: the development of tools that support this formal method of program construction, like ``incremental proof editors''.
<P>
<hr>
Here is a short list of groups in the Netherlands and abroad, currently (1994) working in this area:
<UL><LI>
Utrecht University (NL):
<a href="http://www.cs.ruu.nl/~doaitse">Doaitse Swierstra</a>, <a href="http://www.cs.ruu.nl/~erik">Erik Meijer</a>, and other members of <a href="http://www.cs.ruu.nl/~cja/MoP">the MoP group</a>.
<LI>
CWI, Amsterdam (NL):
<a href="http://www.cwi.nl/~lambert">Lambert Meertens</a> and his group.
<LI>
Technical University of Eindhoven (NL):
<a href="http://www.win.tue.nl/win/cs/wp/rolandb/home.html">Roland Backhouse</a>, <a href="http://www.win.tue.nl/win/cs/wp/japie/home.html">Jaap van der Woude</a>, and other members of <a href="http://www.cs.ruu.nl/~cja/MoP">the MoP group</a>.
<LI>
University of Twente (NL):
<a href="index.html">Maarten Fokkinga</a>.
<LI>
the Programming Research Group at Oxford University (UK):
<a href="http://www.comlab.ox.ac.uk/oucl/people/richard.bird.html">Richard Bird</a>, <a href="">Carroll Morgan</a>, <a href="http://www.comlab.ox.ac.uk/oucl/people/oege.demoor.html">Oege de Moor</a>.
<LI>
Chalmers University (SE):
<a href="http://www.cs.chalmers.se/pub/users/johanj/home.html">Johan Jeuring</a>, <a href="http://www.cs.ruu.nl/~graham">Graham Hutton</a>.
</UL> 
</BODY>
